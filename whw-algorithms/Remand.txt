day1: 位运算 选择排序 冒泡排序 插入排序
day2: 数组求和问题  前缀和 对数器
数组求和问题: 一个数组求随机 两个索引之间数的和
解法：
1 前缀和 用一个新数组 和原数组一样长度
  每个位置存的是 原数组这个位置之前的和
  这样当你输入两个索引的时候 当第一个索引为0时 和就为新数组后面索引位置的值
  当第一个索引不为0时 两个索引之间的和就是 新数组[lastIndex]-新数组[firstIndex-1]
2 利用二维数组
     0   1   2   3  4  5
   0
   1
   2
   3
   4
   5
   第一个索引是竖着的  第二个索引是横着的 0 0存的值是索引 0-0的和 就是原数组[0]
   0-1 存的值就是原数组[0]+原数组[1]
   0-2 存的值就是原数组[0]+原数组[1]+原数组+[2]
   这样和可以直接从这个二维数组中直接取出  当第一个索引位置>第二个索引位置 不存值(不存在这种可能)
   这样占用的空间就是N*N/2
对数器:
  Math.random() [0,1)可以均等概率的返回0-1之间的数  double类型 得到这个数的概率为X X为要想的值
  获取X 概率为X的二次方怎么获得
  两个题目:
  1 已知一个函数可以概率相等的获取1-5 概率相等的获取23-65
  2 一个函数可以概率不等的获取到0-1 改成均等获取0-1
  详情 day2 类 LogarithmicProblemDemo
用对数器的知识检测数组排序时候正确：
   利用Math.random()生成一个随机的数组 长度随机 数据随机
   经过大量循环生成随机数组 排序后检查是否正确
day3:
问题:
1: 一个有序的数组 找一个数是否存在
2: 在有序的数组中找到>=num最左位置
3: 在有序的数组中找到<=num最右位置
4: 一个数组无序 任意相邻位置不等 局部最小
  局部最小定义 arr[0]<arr[1] 0位置局部最小
  arr[n-1] <arr[n-2] n-1位置局部最小
  arr[i-1] > arr[i] arr[i]<arr[i+1] i 位置局部最小

二分是否一定要有序: 不一定 只要能确定一定有 就可以二分
day4:
  1:实现单链表和双链表的反转
  2:用单向链表实现队列和栈
  3:用双向链表实现双向队列
  4:K个节点组内的逆序调整
    给定一个单链表的头节点head，和一个正数K
    实现K个节点的小组内部逆序，如果最后一组不够K个不调整
    例子:
    调整前: 1->2->3->4->5->6->7->8 k=3
    调整后: 3->2->1->6->5->4->7->8
  5:两个链表相加 给定两个链表的头节点head1和head2
    认为从左到右是某个数字从低位到高位，返回相加后的链表
    例子: 4->3->6  2->5->3
    返回: 6->8->9
    解释: 634+352=986 如果链表不一样长 1->2->3 2->3 321+31=352 返回 2->5->3
  6:两个有序的链表合并 合并之后依然有序
    1->3->3->5 2->4->3->7
    返回 1->2->3->3->3->4->5->7
day5:
  写一个bitmap
  不用+-*/来计算